import { getAddress } from "ethers/src.ts/address";
import { keccak256 } from "ethers/src.ts/crypto";
import { recoverAddress } from "ethers/src.ts/transaction";
import {
    assertArgument, concat, encodeRlp, toBeArray
} from "ethers/src.ts/utils";

import type { Addressable } from "ethers/src.ts/address";
import type { SignatureLike } from "ethers/src.ts/crypto";
import type { BigNumberish, Numeric } from "ethers/src.ts/utils";

export interface AuthorizationRequest {
    address: string | Addressable;
    nonce?: Numeric;
    chainId?: BigNumberish;
}

/**
 *  Computes the [[link-eip-7702]] authorization digest to sign.
 */
export function hashAuthorization(auth: AuthorizationRequest): string {
    assertArgument(typeof(auth.address) === "string", "invalid address for hashAuthorization", "auth.address", auth);
    return keccak256(concat([
        "0x05", encodeRlp([
            (auth.chainId != null) ? toBeArray(auth.chainId): "0x",
            getAddress(auth.address),
            (auth.nonce != null) ? toBeArray(auth.nonce): "0x",
        ])
    ]));
}

/**
 *  Return the address of the private key that produced
 *  the signature %%sig%% during signing for %%message%%.
 */
export function verifyAuthorization(auth: AuthorizationRequest, sig: SignatureLike): string {
    return recoverAddress(hashAuthorization(auth), sig);
}
